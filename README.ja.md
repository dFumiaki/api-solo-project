# データベース II

## 目次

1.  [イントロダクション](#イントロダクション)
1.  [目的](#目的)
1.  [トピックの概要](#トピックの概要)
    1.  [Knex](#knex)
    1.  [スキーマ](#スキーマ)
    1.  [マイグレーション](#マイグレーション)
1.  [はじめに](#はじめに)
    1.  [依存ライブラリのインストールとサーバの起動](#依存ライブラリのインストールとサーバの起動)
1.  [基本演習](#基本演習)
1.  [追加の演習](#追加の演習)
1.  [リソース](#リソース)

## イントロダクション

ここまでくれば、SQL クエリを書いたり、データベースを操作することに慣れてきたことでしょう。
しかし、データベースに格納されたデータにより簡単にアクセスすることはできないのでしょうか？全ての人が SQL を学んだり、ターミナルを使わなければならないのでしょうか？
もちろん、SQL を学ぶことを重要ですが、SQL を使わずとも Web インタフェースを介してデータベースに簡単にアクセスすることができるのです。
このスプリントでは、README の指示に従って 1 つずつ課題を解きながら、Web アプリケーションとデータベースを実際に繋げてデータのやり取りを行う方法を試してみましょう。

## 目的

- Express サーバーとデータベースを接続できるようになる
- クエリビルダーのライブラリ(Knex)の扱い方に慣れる
  - アプリケーションコードからデータベースのデータを参照する
  - アプリケーションコードからデータベースのデータを変更する
- SQL がどうやって機能するのか、さらに理解を深める
- Web クライアント（HTML ページ）が、Web サーバーを介してデータにアクセスする方法を理解する。

## トピックの概要

### Knex

アプリケーションコードに生の SQL を書くことはできますが、面倒であまり安全な方法とは言えません。
もっと Javascript 的な方法で SQL を書けるといいですね。
[Knex](http://knexjs.org/) はそのためのライブラリで、今回のスプリントではこのライブラリを使っていくことなります。
ドキュメントを頻繁に参照することになるので、ドキュメントを別タブに開いておくことをお勧めします。
簡単に言うと、Knex はクエリビルダーです。通常の Javascript でクエリを書くことができ、SQL に変換してくれます。

### スキーマ

データベースのスキーマはこちらから確認できます: `/docs/schema.md`。
データベースのテーブルをセットアップするときに参考にしてください。
このスプリントでは、ショップ（shop）のデータベースを構築していきます。データベースのテーブルには、顧客（customers）、商品（products）、顧客の注文（customer orders）に関するデータを格納します。
スキーマは、データベースの名前、データ型、および制約を定義したものです。また他にも、インデックスやテーブルのリレーションなど、データベースのプロパティも定義します。データベースを構築する前に、まずスキーマを計画・設計するのは良い考えです。このスプリントでは、計画・設計のステップはすでにできているので心配はいりません。

### マイグレーション

データベースのスキーマを変更（テーブルの追加、削除、変更）するときは、必ずマイグレーションを行います。マイグレーションとは、何らかの方法でデータベースを変更し、新しいスキーマを適用しデータを変更するための一連のクエリ処理のことです。
マイグレーションは **常に** トランザクション内で行わなければなりません。
スキーマの変更が 「すべて適用される」か、あるいは「まったく適用されない」ようにするため、トランザクション内でマイグレーションを定義する必要があります。
Knex のマイグレーションはデフォルトでトランザクションを使用するので、マイグレーションファイルで明示的にトランザクションを記述する必要はありません。

**重要**: マイグレーションファイルは実行後、決して削除したり編集したりしないでください。
もし、実行後にマイグレーション内に間違いが見つかった場合は、データベースを更新するために **新しい** マイグレーションを作成する必要があります。

## はじめに

### Postgres

Postgres をインストールする必要があります。まだインストールしていない場合は、[PostgresApp](https://postgresapp.com/) をダウンロードしてインストールし、ターミナルで `psql` というコマンドを実行して正常にインストールできているかどうか確認しましょう。

### 依存ライブラリのインストールとサーバの起動

依存ライブラリをインストールするには、以下のコマンドを実行します:

```bash
    npm install
```

サーバを起動するためには、以下のコマンドを実行します:

```bash
    npm run start
```

サーバーが起動したら、ブラウザで `localhost:3000` を開くと、ナビゲーションバーが付いたミニマムなウェブページが表示されるはずです。
リンクをクリックできますが、データは表示されず、エラーが発生するかもしれません。これは、ウェブページがまだセットアップしていないデータベースからデータをロードしようとしているためです。

また、コードを書きながらテストを実行したくなるでしょう。
テストを実行するためには、以下のコマンドを実行します:

```bash
    npm run test
```

## 基本演習

### データベースのセットアップ

- [ ] `.env.local` というファイルを作成し、`.env.example` の内容をこのファイルにコピーしましょう。
  - 上記のファイルを git リポジトリにコミットしてはいけません!
  - [ ] 上記のファイルの環境変数をローカルのデータベース設定と一致するように設定しましょう。
  - [ ] DB_NAME、DB_USER、DB_PASSWORD を設定しましょう。引用符やスペースは使用しないでください。
- [ ] データベースを作成します。`echo "CREATE DATABASE cc_store;" | psql`
  - [ ] データベースが存在することを確認します。
    - `psql -d cc_store` (このコマンドで、エラーなくデータベースに接続するはずです)

#### マイグレーションによるデータベーステーブルの構築

マイグレーションについては、上記の "トピックの概要" をお読みください。
`/db/migrations` にマイグレーションファイルを作成してあります。このファイルの中身を見て、何をやっているのか見てみましょう。
主に、`customer` という名前の新しいテーブルを作成し、適切なデータ型のカラムを追加しています。
このテーブルを `docs/schema.md` にあるスキーマと比較してみてください。マイグレーションファイルのテーブルとカラムの名前がスキーマと一致していることに注目してみてください。
データ型は少し違いますが (例えば `varchar` と `string`) 、これは Knex と Postgres が同じデータ型を違う名前で呼んでいるからです。
型については、[Knex schema builder documentation](https://knexjs.org/guide/schema-builder.html#schema-building) で詳しく説明されています。

- [ ] 最初のマイグレーションを実行しましょう: `npm run migrate`.
  - 上記のコマンドは db/migrations にあるファイルを使用して、データベースに変更を加えます。
- [ ] マイグレーションでテーブルが作成されたことを確認しましょう。
  - `psql -d cc_store` を実行。
  - PSQL セッションで次のように入力します: `\dt`
  - `customer` テーブルを含めたテーブルのリストが表示されるはずです。
- [ ] customer テーブルを修正します。customer のスキーマの内、カラムの 1 つがテーブルから欠けています! customer のスキーマデザインには `city` というカラムがありますが、customer テーブルには存在しません。psql で `d customer` を実行すると、テーブルのカラムが確認できます。
  - [ ] 既存のマイグレーションファイルを **編集しない** でください！ Knex CLI を使用して新しいマイグレーションファイルを作成しましょう: `knex migrate:make update_customer_table`
  - [ ] マイグレーションファイルの `up` 関数内に、文字列（string）型の `city` という名前のカラムを追加する Knex のマイグレーション処理を記述しましょう。
    - 新しいカラムを追加する方法については、Knex のドキュメントを参照してください。
  - [ ] マイグレーションファイルの `down` 関数内に、 `up` の逆の操作、つまり `city` カラムを削除する処理を記述しましょう。
    - down 関数は、Knex の **rollback** コマンドが呼ばれたときに実行され、マイグレーションを切り戻し（ロールバック）させます。
    - ロールバックはデータが失われる可能性があるため、安易に本番環境のデータベースでは使用しないでください。
    - ロールバックは、マイグレーションがデータベーススキーマを元の状態に戻す（現在のデータベースの状態を破壊し、前の状態に戻す）必要がある場合に使用されます。
    - マイグレーションは正常に実行されたが、処理に間違いがあった場合、ロールバックを使用しないで、必ず代わりに新しいマイグレーションを作成するようにしてください。
  - [ ] マイグレーションを実行しましょう: `npm run migrate`
  - [ ] PSQL でテーブルのカラムをチェックし、マイグレーションが実行されたことを確認します: `\d customer`
    - customer テーブルに `city` カラムが存在するはずです。
- [ ] `knex migrate:make` コマンドを使用して、以下のテーブルのマイグレーションファイルを作成します:
  - [ ] `product` テーブルのマイグレーション
  - [ ] `order_info` テーブルのマイグレーション
  - [ ] `order_product` テーブルのマイグレーション
- [ ] 生成された各マイグレーションファイルの `up` と `down` の関数を完成させましょう。
  - 参考として `/docs/schema.md` にあるスキーマと Knex スキーマビルダーのドキュメントを見てみましょう。
  - テーブル間で外部キーの参照が定義されていることを確認してください (例: `order_info.customer_id` は `customer.id` を参照します)
- [ ] マイグレーションを実行します: `npm run migrate`
- [ ] PSQL でテーブルのカラムをチェックして、マイグレーションが実行されたことを確認しましょう: `\dt`

#### シード（seeds）を使った開始データのデータベースのセットアップ

今、あなたのデータベースにはテーブルがあるはずですが、すべて中身が空っぽです。テーブルのうち一つに対して select クエリを実行してみてください (例. `SELECT * FROM customer;`)
ローカルのデータベースにテストデータを入れるために、いくつかの初期データの行（レコード）を挿入（insert）するスクリプトを使用できます。このスクリプトは _シード（seed）_ ファイルと呼ばれます。
`db/seeds` ディレクトリにシードファイルを予め作成しておきました。何をやっているのか理解するために、ざっと見てみてください。
主に、customer テーブルに数行のデータを挿入（insert）しているだけです。
[Knex のドキュメント](https://knexjs.org/guide/migrations.html#seed-cli)でシード（seeds）についての解説も読めます。

- [ ] `npm run seed` を実行して、シードスクリプトを実行しましょう。
- [ ] エラーなくシードが実行されることを確認し、次のクエリを実行してデータベースの customer テーブルをチェックしましょう: `SELECT * FROM customer;`
  - これで、いくつかのクエリ結果が表示されるはずです。
- [ ] 他のテーブルにデータを追加するために、シードスクリプトを記述しましょう:
      **注意** いくつかのテーブルは外部キー(customer 参照)を含んでいるので、外部テーブルの既存の id と一致する値を挿入する必要があります (例. `order_product.product_id` は `product` テーブルに存在する id を参照しなければなりません)
  - [ ] `product` テーブルに対してシードスクリプトを実行しましょう。
    - [ ] knex cli でシードスクリプトを生成します: `knex seed:make product_seed`
      - 上記のコマンドで、`db/seeds` ディレクトリに新しいファイルが作成されます。
    - [ ] 挿入するデータをシードスクリプトファイルに記述します。
    - [ ] シードスクリプトのコマンドを実行します: `npm run seed`
  - [ ] `order_info` テーブルに対してシードスクリプトを実行しましょう。
    - [ ] knex cli でシードスクリプトを生成します。
    - [ ] 挿入するデータをシードスクリプトファイルに記述します。
    - [ ] シードスクリプトのコマンドを実行します: `npm run seed`
  - [ ] `order_product` テーブルに対してシードスクリプトを実行しましょう。
    - [ ] knex cli でシードスクリプトを生成します。
    - [ ] 挿入するデータをシードスクリプトファイルに記述します。
    - [ ] シードスクリプトのコマンドを実行します: `npm run seed`

ここまででローカルのデータベースのセットアップが完了し、テーブル内にデータ行（レコード）が登録された状態になっているはずです。

- [ ] PSQL で以下のクエリをそれぞれ実行してみて、データが存在するかどうかを確認しましょう。
  - [ ] `SELECT * FROM product;`
  - [ ] `SELECT COUNT(id) FROM order_info;`
  - [ ] `SELECT last_name FROM customer WHERE id = 1;`
  - [ ] `SELECT * FROM order_product JOIN product ON product.id = order_product.product_id;`

**まだまだ基本演習は続きます**

### Knex クエリビルダーでのデータ接続

データベースのセットアップが完了したら、次はそれを Express サーバーのコードから接続してみましょう。
URL を関数にマッピングする Express のコードは既に記述してあります。src/server.js ファイルでそれらのルートを確認できます。各ルートは、**controller** モジュールのリクエストハンドラ関数を使用しています。
**controller** は **model** モジュールからデータを取得し、ページや **view** としてレンダリングする役割を担っています。
**model** はデータベースとのやりとり（例. 作成、参照、更新、削除）を担当します。
これは基本的な [Model View Controller (MVC)](https://ja.wikipedia.org/wiki/Model_View_Controller) パターンに該当します。

今回のタスクは、Knex のクエリで model 関数を記述することです。model モジュールに該当するファイルは、サフィックスが `*.model.js` になっています。
`src/customer/customer.model.js` にある `getAll` と `getById` 関数を見て、データを取得するために Knex がどのように使われているかを見てみましょう。
これらの関数は、Postgres データベースからレコード（つまり行）を取得し、Javascript のデータ構造として取得するために Knex を使用しています。

[Knex クエリビルダー](https://knexjs.org/guide/query-builder.html)を使用する必要があります。
JSDOC コメントの入力(@param)と出力(@return)がヒントになります。

Knex は、データベースへの接続を処理し、SQL クエリを生成してくれるので便利です。
`knexfile.js` は、データベース接続情報の詳細を Knex 側に渡す場所になります。
もし Knex がなければ、データベース接続を処理するために何らかのスクリプトを書かなければならないでしょう。
また、多くの SQL クエリ（例. `SELECT * FROM ...`）を書かないといけない点も面倒です。エラーにつながったり、セキュリティ上の脆弱性（例えば SQL インジェクション）を引き起こしたりする可能性もあります。

もし、行き詰まったり、どのような Knex メソッドが利用可能かわからない場合は、公式ドキュメントを参照してみましょう。

Knex のクエリビルダーを使って model ファイルに以下の関数を実装してください。すべてのテストをパスする必要があります:

- [ ] Customers (`src/customer/customer.model.js`)
  - [ ] create
  - [ ] update
- [ ] Products (`src/product/product.model.js`)
  - [ ] getById
  - [ ] create
  - [ ] update
- [ ] Orders (`src/order/order.model.js`)
  - [ ] getAll
    - [ ] 顧客 ID を含んだ注文（order）のリストを返す:
  - [ ] getById
    - [ ] 以下の内容を含んだ顧客（customer）データを返す:
      - [ ] customer id
      - [ ] customer last name（顧客の姓）
      - [ ] customer first name（顧客の名）
      - [ ] customer country（顧客の国）
    - [ ] 注文（order）に属するすべての製品（product）のリストを含む:
      - 製品情報は以下の項目を含んでいなければいけません：
      - [ ] product description（製品説明）
      - [ ] product price（製品の金額）
      - [ ] product quantity（製品の数量）
  - [ ] create
    - 注文（order）には必ず customer_id を含めなければいけません。このとき、顧客（customer）テーブルに存在する顧客を使用する必要があります。
  - [ ] update

### 追加の演習

- [ ] 検索パラメータでフィルタリングされた結果を返す model 関数を追加しましょう。
  - [ ] 所在地（location）による顧客のフィルタリング
  - [ ] 在庫（stock）、価格（cost_price）、販売価格（sell_price）による製品のフィルタリング
  - [ ] 注文（orders）を customer_id でフィルタリング
- [ ] フィルタリング関数のテストをいくつか書きましょう
- [ ] クエリ結果をキャッシュし、不要なデータベースクエリを削減しましょう

## リソース

- [Knex ドキュメント](http://knexjs.org/)
